"insert into  wrh$_sysmetric_history  (dbid,  per_pdb,  con_dbid,  snap_id,  instance_number,  begin_time,  end_time,  intsize,  group_id,  metric_id,  value)  select  :dbid,   drmv.con_id,  con_id_to_dbid(drmv.con_id)  con_dbid,   :snap_id,  :instance_number,  begtime,  endtime,  intsize_csec,       groupid,  metricid,  value   FROM x$kewmdrmv   drmv  WHERE  (1 = 1)  AND ( drmv.con_id &lt; 4099  )"
"SELECT /*+ NO_STATEMENT_QUEUING RESULT_CACHE (SYSOBJ=TRUE SHELFLIFE=30) */ &quot;OBJ#&quot;, &quot;CLASS_OID&quot;, &quot;JOB_FLAGS&quot;, &quot;CLASS_FLAGS&quot;, &quot;RUN_TIME&quot;, &quot;PRIORITY&quot;, &quot;JOB_STATUS&quot;, &quot;RUNNING_INSTANCE&quot;, &quot;SCHEDULE_LIMIT&quot;, &quot;JOB_WEIGHT&quot;, &quot;INSTANCE_ID&quot;, &quot;AFFINITY&quot;, &quot;SERVICE_FLAGS&quot; FROM &quot;SYS&quot;.&quot;SCHEDULER$_LWJOB_REFRESH&quot; &quot;SCHEDULER$_LWJOB_REFRESH&quot; WHERE 1=1"
DELETE FROM SYS.WRI$_ADV_ADDM_TODO T WHERE T.DBID = :B3 AND T.INSTANCE_NUMBER = :B2 AND T.END_SNAP_ID = :B1 RETURNING COUNT(*) INTO :O0
"select count(*) num_windows,  sum(case when jobs_started&lt;&gt;jobs_completed then 1 else 0 end) num_jobs_incomplete from  (select x.cname_ketcl client_name,        sum(case when operation = 'RUN'           then 1 else 0 end) as jobs_started,        sum(case when operation = 'RUN' and status = 'SUCCEEDED'           then 1 else 0 end) as jobs_completed  from x$ketcl x,        dba_scheduler_job_log jl,        (select window_name,  window_start_time,  window_end_time        from (          select window_name,             lag(window_name,  1) over (order by log_date ) prev_window_name,             operation,             lag(operation,  1) over (order by log_date ) prev_operation,             lag(log_date,  1) over (order by log_date ) window_start_time,             log_date window_end_time          from dba_scheduler_window_log          where operation in  ('OPEN',  'CLOSE'))        where operation = 'CLOSE' and prev_operation = 'OPEN'          and window_name = prev_window_name) WLOG where (bitand(x.attr_ketcl, 2048) = 0     or 999999 &lt; (select to_number(value)                    from v$system_parameter                   where name = '_automatic_maintenance_test'))   and x.cid_ketcl &gt; 0   and jl.job_class in (x.hjc_ketcl, x.ujc_ketcl, x.mjc_ketcl)   and jl.log_date between wlog.window_start_time                       and wlog.window_end_time group by x.cname_ketcl,  wlog.window_name,  wlog.window_start_time,           wlog.window_end_time - wlog.window_start_time,            wlog.window_end_time ) where client_name = 'auto optimizer stats collection'"
select property  from wri$_adv_tasks where id = :task_id
select max(scn) from smon_scn_time
"merge /* KSXM:OPTIM_DML_INF */  into sys.mon_mods_all$ m                   using dual                                                                 on (m.obj# = :objn and                                                         (:pobjn = 0 or                                                              m.obj# = :pobjn or                                                         m.obj# in (select obj#                                                                from tabpart$                                                              where bo# = :pobjn and obj# = :objn                                        union all                                                                  select obj#                                                                from tabcompart$                                                           where bo# = :pobjn and obj# = :objn                                        union all                                                                  select tsp.obj#                                                            from tabsubpart$ tsp,  tabcompart$ tcp                                      where tsp.pobj# = tcp.obj#                                                   and (tcp.bo# = :pobjn or tcp.obj# = :pobjn)                                and tsp.obj# = :objn)))                                  when matched then                                                            update                                                                     set inserts = decode(:reset,  1,  0,  inserts) + :ins,                             updates = decode(:reset,  1,  0,  updates) + :upd,                             deletes = decode(:reset,  1,  0,  deletes) + :del,                             flags =  decode(:reset,  1,  0,  flags - bitand(flags,  :flag)) + :flag,        drop_segments = decode(:reset,  1,  0,  drop_segments) + :dropseg,             timestamp = :time                                                    when NOT matched then                                                        insert (obj#,  inserts,  updates,  deletes,                                            timestamp,  flags,  drop_segments)                                   values (:objn,  :ins,  :upd,  :del,  :time,  :flag,  :dropseg)                   where :ins != 0 or :upd != 0 or :del != 0 or :flag != 0 or :dropseg !=0"
"MERGE /*+ OPT_PARAM('_parallel_syspls_obey_force' 'false') */ INTO OPTSTAT_USER_PREFS$ D USING ( SELECT * FROM (SELECT O.OBJ#,  SYSTIMESTAMP CHGTIME,  ROUND(MAX(S.DELTA_READ_IO_BYTES/S.DELTA_TIME),  3) SCANRATE FROM GV$ACTIVE_SESSION_HISTORY S,  GV$SQL_PLAN P,  OBJ$ O,  USER$ U WHERE S.INST_ID = P.INST_ID AND S.SQL_ID = P.SQL_ID AND S.SQL_PLAN_HASH_VALUE = P.PLAN_HASH_VALUE AND S.SQL_PLAN_LINE_ID = P.ID AND P.OBJECT_NAME = O.NAME AND (:B4 IS NULL OR O.OBJ# = :B4 ) AND O.OWNER# = U.USER# AND P.OBJECT_OWNER = U.NAME AND O.TYPE# = 2 AND S.CON_ID = SYS_CONTEXT('userenv',  'con_id') AND P.CON_ID = SYS_CONTEXT('userenv',  'con_id') AND S.SQL_PLAN_OPERATION = 'TABLE ACCESS' AND P.OPERATION = 'TABLE ACCESS' AND S.DELTA_TIME &gt; 0 AND S.DELTA_READ_IO_BYTES &gt; 0 AND FROM_TZ(S.SAMPLE_TIME,  :B3 ) &gt; :B2 AND (:B1 = 'ON' OR (:B1 = 'HADOOP_ONLY' AND EXISTS ( SELECT NULL FROM SYS.EXTERNAL_TAB$ ET WHERE ET.OBJ# = O.OBJ# AND TYPE$ IN ('ORACLE_HIVE',  'ORACLE_HDFS',  'ORACLE_BIGDATA')))) GROUP BY O.OBJ#) C WHERE NOT EXISTS (SELECT NULL FROM OPTSTAT_USER_PREFS$ PR WHERE PNAME = 'SCAN_RATE' AND C.OBJ# = PR.OBJ# AND (PR.SPARE1 IS NULL OR C.SCANRATE &lt;= TO_NUMBER(PR.VALCHAR))) ) SRC ON (D.OBJ#=SRC.OBJ# AND D.PNAME = 'SCAN_RATE') WHEN MATCHED THEN UPDATE SET D.VALCHAR= TO_CHAR(SRC.SCANRATE),  D.CHGTIME=SRC.CHGTIME,  D.SPARE1=1 WHEN NOT MATCHED THEN INSERT (OBJ#,  PNAME,  VALCHAR,  CHGTIME,  SPARE1) VALUES(SRC.OBJ#,  'SCAN_RATE',  TO_CHAR(SRC.SCANRATE),  SRC.CHGTIME,  1)"
"select group_tbid_kewrtbgm,  member_tbid_kewrtbgm from  (select * from x$kewrtbgm  where con_id = :con_id_01 or (   (:con_id_02 = 1        and con_id = 0)  or (:con_id_03 = 0        and con_id = 1))  )"
"select tb.table_id_kewrtb,  fl.flvl_int_kewflinfo from  WRM$_TABLE_SETTINGS  ts,   (select * from x$kewrtb  where con_id = :con_id_01 or (   (:con_id_02 = 1        and con_id = 0)  or (:con_id_03 = 0        and con_id = 1))  )  tb,   (select * from x$kewflinfo  where con_id = :con_id_04 or (   (:con_id_05 = 1        and con_id = 0)  or (:con_id_06 = 0        and con_id = 1))  )  fl where  ts.dbid = :dbid and    upper(ts.table_name) = upper(tb.table_name_kewrtb) and    ts.flush_level_val = fl.flvl_val_kewflinfo (+)"
SELECT count(*) FROM wri$_adv_executions e                 WHERE e.name = :exec_name and e.task_id = 293
"select /*+ connect_by_filtering index(sysauth$ i_sysauth1) */ privilege#,  bitand(nvl(option$,  0),  72),  grantee#,  level from sysauth$ connect by grantee#=prior privilege# and privilege#&gt;0 start with grantee#=:1 and privilege#&gt;0"
BEGIN /* KSXM:FLUSH DML_MON */    dbms_stats_internal.gather_scan_rate_by_mmon;  END;
select property from wri$_adv_tasks where id = :task_id
select TIME_WAITED_MICRO from V$SYSTEM_EVENT  where event = 'Shared IO Pool Memory'
"select shared_pool_size_for_estimate s,           shared_pool_size_factor * 100 f,           estd_lc_load_time l,  0             from v$shared_pool_advice"
select count(*) from undo$
"insert into  wrh$_mvparameter  (dbid,  per_pdb,  con_dbid,  snap_id,  instance_number,  parameter_hash,  ordinal,  value,  isdefault,  ismodified)  select  :dbid,   sv.con_id,  con_id_to_dbid(sv.con_id)  con_dbid,   :snap_id,  :instance_number,  sv.hash,  sv.ordinal,  substr(sv.value,  1,  512),  sv.isdefault,  sv.ismodified  from v$system_parameter2    sv  where exists (select 1 from v$system_parameter4    i  where i.num = sv.num                    and bitand(i.param_flag, 32) = 32)"
"insert into  wrh$_sga_target_advice  (dbid,  per_pdb,  con_dbid,  snap_id,  instance_number,     SGA_SIZE,  SGA_SIZE_FACTOR,  ESTD_DB_TIME,  ESTD_PHYSICAL_READS)  select  :dbid,   ta.con_id,  con_id_to_dbid(ta.con_id)  con_dbid,   :snap_id,  :instance_number,     SGA_SIZE,  SGA_SIZE_FACTOR,  ESTD_DB_TIME,  ESTD_PHYSICAL_READS   FROM v$sga_target_advice    ta  WHERE  (1 = 1)  AND ( ta.con_id &lt; 4099  )"
"select o.owner#, o.name, o.namespace, o.remoteowner, o.linkname, o.subname from obj$ o where o.obj#=:1"
"select java_pool_size_for_estimate s,            java_pool_size_factor * 100 f,            estd_lc_load_time l,  0            from v$java_pool_advice"
"insert into  wrh$_parameter  (dbid,  per_pdb,  con_dbid,  snap_id,  instance_number,  parameter_hash,  value,  isdefault,  ismodified)  select  :dbid,   sp.con_id,  con_id_to_dbid(sp.con_id)  con_dbid,   :snap_id,  :instance_number,  hash,  substr(value,  1,  512),  isdefault,  ismodified  from v$system_parameter    sp"
"select s.file#,  s.block#,  s.ts#,  t.obj#,  s.hwmincr,  t.obj# from tab$ t,  seg$ s where bitand(s.spare1,  4503599627370496) = 4503599627370496 and bitand(s.spare1,  65536) &lt;&gt; 65536  and s.file# = t.file# and s.ts# = t.ts# and s.block# = t.block# UNION  select s.file#,  s.block#,  s.ts#,  t.obj#,  s.hwmincr,  tab.obj# from tabpart$ t,  tab$ tab,  seg$ s  where bitand(s.spare1,  4503599627370496) = 4503599627370496 and bitand(s.spare1,  65536) &lt;&gt; 65536  and s.file# = t.file# and s.ts# = t.ts# and s.block# = t.block# and tab.obj# = t.bo# UNION  select s.file#,  s.block#,  s.ts#,  t.obj#,  s.hwmincr,   tab.obj# from tabsubpart$ t,  tab$ tab,  tabcompart$ tcp,   seg$ s  where bitand(s.spare1,  4503599627370496) = 4503599627370496 and bitand(s.spare1,  65536) &lt;&gt; 65536  and s.file# = t.file# and s.ts# = t.ts# and s.block# = t.block# and t.pobj# = tcp.obj# and tab.obj# = tcp.bo#"
"select   /*jskqjobqlod2*/   /*+ no_monitor no_statement_queuing current_instance */   nvl(con_id,  0) CON_ID,     obj# OBJOID,    class_oid CLSOID,          run_time RUNTIME,    2 * priority +    decode(bitand(job_status,  4),  0,  0,           decode(instance_id,  :inst_id,  -1,  1)) PRIORITY,    1 JOBTYPE,    schedule_limit SCHLIM,     job_weight WEIGHT,    decode(running_instance,  NULL,  0,  running_instance) INST,    decode(bitand(job_flags,  16384),  0,  0,  1) RUNNOW,    decode(bitand(job_status,  8388608),  0,  0,  1) ENQ_SCHLIM,    affinity SRVNAME,    decode(bitand(job_status,  1073741824),  0,  0,  1) IS_AQ_JOB  from (   select     con_id,         obj#,        class_oid,         run_time,      priority,       job_status,  running_instance,  schedule_limit,      job_weight,     job_flags,   affinity,          instance_id,      service_flags,  class_flags   from     containers(sys.scheduler$_job_refresh)   where         (   database_role = :db_role          or database_role = 'ALL'          or (    database_role is null              and :db_role = 'PRIMARY'))     and (   :guard_role &lt;&gt; 'ALL'          or database_role = 'ALL') union all   select     con_id,         obj#,        class_oid,         run_time,      priority,       job_status,  running_instance,  schedule_limit,      job_weight,     job_flags,   affinity,          instance_id,      service_flags,  class_flags   from     containers(sys.scheduler$_lwjob_refresh)   where        :rac_on = 0     or running_instance = :inst_id) where       run_time &lt;= :lookahead   and bitand(job_flags,  1048576) = 0   and (   (    class_oid is not null            and instance_id is null            and bitand(class_flags,  :aff_type) &lt;&gt; 0            and (   (    :def_serv = 0                     and lower(affinity) = lower(:aff)                     and bitand(nvl(service_flags,  0),  128) = 0)                 or (    :def_serv = 1                     and (   lower(affinity) = lower(:aff)                          or bitand(nvl(service_flags,  0),  128) = 128))))        or (    :aff_type = 1            and instance_id is not null            and instance_id = :inst_id)) order by RUNTIME,  CLSOID,  PRIORITY,  WEIGHT DESC,  OBJOID"
update /* KSXM:TIME_UPD */ optstat_hist_control$ set sval2 = systimestamp  where sname = :param_name
update WRM$_DATABASE_INSTANCE set    last_ash_sample_id = :last_ash_sample_id where  instance_number    = :instance_number   and  dbid               = :dbid   and  startup_time = (select max(startup_time)                        from   WRM$_DATABASE_INSTANCE                        where  instance_number = :instance_number2                          and  dbid            = :dbid2 )
"select size_for_estimate,                       size_factor * 100 f,                     estd_physical_read_time,                 estd_physical_reads              from v$db_cache_advice where id = '3'"
"insert /* KSXM:TAKE_SNPSHOT */ into sys.optstat_snapshot$ (obj#,  inserts,  updates,  deletes,  timestamp,  flags) (select m.obj#,  m.inserts,  m.updates,  m.deletes,  systimestamp,   dbms_stats_advisor.compute_volatile_flag(    m.obj#,  m.flags,  :flags,  m.inserts,  m.updates,  m.deletes,     s.inserts,  s.updates,  s.deletes,  null,     nvl(to_number(p.valchar),  :global_stale_pcnt),  s.gather) flags from sys.mon_mods_all$ m,  (select si.obj#,  max(si.inserts) inserts,  max(si.updates) updates,     max(si.deletes) deletes,  decode(bitand(max(si.flags),  :gather_flag),  0,                                'NO_GATHER',  'GATHER') gather,     max(si.timestamp) timestamp  from sys.optstat_snapshot$ si,   (select obj#,  max(timestamp) ts from sys.optstat_snapshot$   group by obj#) sm  where si.obj# = sm.obj# and si.timestamp = sm.ts  group by si.obj#) s,  sys.optstat_user_prefs$ p where m.obj# = s.obj#(+)  and m.obj# = p.obj#(+) and pname(+) = 'STALE_PERCENT'  and dbms_stats_advisor.check_mmon_policy_violation(rownum,  6,  2) = 0)"
SELECT /*+ OPT_PARAM('_parallel_syspls_obey_force' 'false') */ SPARE4 FROM SYS.OPTSTAT_HIST_CONTROL$ WHERE SNAME = :B1
"select count(*) from wri$_optstat_opr o,  wri$_optstat_opr_tasks t where o.id = t.op_id(+) and o.operation = 'gather_database_stats (auto)' and ((o.notes like '%&lt;error&gt;%' and  not regexp_like( o.notes,  '&lt;error&gt;ORA-200[0-9][0-9]')) or  (t.notes like '%&lt;error&gt;%' and  not regexp_like( t.notes,  '&lt;error&gt;ORA-200[0-9][0-9]'))) and  rownum=1"
"select   /*jskqjobqlod1*/   /*+ no_monitor no_statement_queuing current_instance */   nvl(CON_ID,  0) CON_ID,   OBJOID,    CLSOID,                  RUNTIME,    2 * PRIORITY +    decode(bitand(STATUS,  4),  0,  0,            decode(INST,  :inst_id,  -1,  1)) PRIORITY,    JOBTYPE,                 SCHLIM,    WEIGHT,                  INST,    RUNNOW,    decode(bitand(STATUS,  8388608),  0,  0,  1) ENQ_SCHLIM,    NULL AFFINITY from (   select     CON_ID,              obj# OBJOID,      class_oid CLSOID,    run_time RUNTIME,      job_status STATUS,   PRIORITY,      1 JOBTYPE,           schedule_limit SCHLIM,      job_weight WEIGHT,      decode(running_instance,  NULL,  0,  running_instance) INST,      decode(bitand(job_flags,  16384),  0,  0,  1) RUNNOW   from (     select       con_id,         obj#,        class_oid,         run_time,        priority,       job_status,  running_instance,  schedule_limit,        job_weight,     job_flags,   affinity,          instance_id     from       containers(sys.scheduler$_job_refresh)     where           (   database_role = :db_role            or database_role = 'ALL'            or (    database_role is null                and :db_role = 'PRIMARY'))       and (   :guard_role &lt;&gt; 'ALL'            or database_role = 'ALL')       and bitand(job_flags,  1048576) = 0   union all     select       con_id,         obj#,        class_oid,         run_time,        priority,       job_status,  running_instance,  schedule_limit,        job_weight,     job_flags,   affinity,          instance_id     from       containers(sys.scheduler$_lwjob_refresh)     where          :rac_on = 0       or running_instance = :inst_id)   where         run_time &lt;= :lookahead     and instance_id is null     and (   class_oid is null          or affinity is null) union all   select     con_id,      obj#,        0,      start_date,   0,          0,      decode(bitand(flags,  64),  64,  3,  2),      duration,      1,           0,           0   from     containers(scheduler$_window_refresh)   where     start_date &lt;= :lookahead union all   select     con_id,      obj#,        0,      start_date + duration,      0,           0,      decode(bitand(flags,  64),  64,  5,  4),      numtodsinterval(0, 'minute'),      1,           0,           0   from     containers(scheduler$_window_refresh)   where     start_date &lt;= :lookahead ) /*jskqjobqlod1*/ order by RUNTIME,  JOBTYPE,  CLSOID,  PRIORITY,  WEIGHT DESC,  OBJOID"
select null from optstat_hist_control$              where sname = 'SNAPSHOT_UPD_TIME'                                                         and ((systimestamp - sval2) &gt; INTERVAL '3060' SECOND                              or sval2 is null)  for update
select file# from file$ where ts#=:1
"SELECT COUNT(*) FROM (SELECT KSPPIHASH,  KSPPINM FROM X$KSPPI NT MINUS SELECT PARAMETER_HASH,  PARAMETER_NAME FROM WRH$_PARAMETER_NAME WHERE dbid = :dbid)"
select /*+ no_parallel */ spare4 from sys.optstat_hist_control$ where sname=:1
"select sql_id,  sql_exec_id,  dbop_name,  dbop_exec_id,  to_char(sql_exec_start,  'mm:dd:yyyy hh24:mi:ss'),  to_char(first_refresh_time,  'mm:dd:yyyy hh24:mi:ss'),  to_char(last_refresh_time,  'mm:dd:yyyy hh24:mi:ss'),  elapsed_time,  px_servers_allocated,  sid,  session_serial#,  key,  con_id from v$sql_monitor where report_id = 0 and       status != 'EXECUTING' and       status != 'QUEUED' and       px_qcsid is null and       last_refresh_time &gt;         (select nvl(last_cycle_time,  sysdate-(5/1440))          from v$sys_report_stats)"
"select dbid,  status_flag from wrm$_wr_control order by mrct_snap_time_num desc"
"update wri$_adv_tasks set mtime = SYSDATE,           last_exec_name = :last_execution,           status = nvl(:new_status,  status),           cleanup = nvl(:new_cleanup,  cleanup),           version = nvl(:db_version,  version)    where id = :task_id"
"select con_id  from v$containers    where open_mode in ('READ WRITE',  'READ ONLY')"
"insert into  wrh$_latch  (dbid,  per_pdb,  con_dbid,  snap_id,  instance_number,  latch_hash,  level#,  gets,  misses,     sleeps,  immediate_gets,  immediate_misses,  spin_gets,  sleep1,     sleep2,  sleep3,  sleep4,  wait_time)  select  :dbid,   ltch.con_id,  con_id_to_dbid(ltch.con_id)  con_dbid,   :snap_id,  :instance_number,   hash,  level#,  gets,     misses,  sleeps,  immediate_gets,  immediate_misses,  spin_gets,     sleep1,  sleep2,  sleep3,  sleep4,  wait_time  FROM v$latch    ltch  WHERE  (1 = 1)  AND ( ltch.con_id &lt; 4099  )"
"BEGIN          sys.prvt_hdm.auto_execute(            db_id =&gt; :bind_dbid,            inst_id =&gt; :bind_inst,            end_snap =&gt; :bind_snap,            time_left_in_secs =&gt; :bind_time);        END;"
"insert into  wrh$_instance_recovery  (dbid,  per_pdb,  con_dbid,  snap_id,  instance_number,  recovery_estimated_ios,  actual_redo_blks,  target_redo_blks,  log_file_size_redo_blks,  log_chkpt_timeout_redo_blks,  log_chkpt_interval_redo_blks,  fast_start_io_target_redo_blks,  target_mttr,  estimated_mttr,  ckpt_block_writes,  optimal_logfile_size,  estd_cluster_available_time,  writes_mttr,  writes_logfile_size,  writes_log_checkpoint_settings,  writes_other_settings,  writes_autotune,  writes_full_thread_ckpt) select  :dbid,   instrecvry.con_id,  con_id_to_dbid(instrecvry.con_id)  con_dbid,   :snap_id,  :instance_number,  recovery_estimated_ios,  actual_redo_blks,  target_redo_blks,  log_file_size_redo_blks,  log_chkpt_timeout_redo_blks,  log_chkpt_interval_redo_blks,  fast_start_io_target_redo_blks,  target_mttr,  estimated_mttr,  ckpt_block_writes,  optimal_logfile_size,  estd_cluster_available_time,  writes_mttr,  writes_logfile_size,  writes_log_checkpoint_settings,  writes_other_settings,  writes_autotune,  writes_full_thread_ckpt  FROM v$instance_recovery    instrecvry  WHERE  (1 = 1)  AND ( instrecvry.con_id &lt; 4099  )"
"UPDATE WRH$_SEG_STAT_OBJ SET snap_id = :lah_snap_id  WHERE dbid = :dbid    AND (TS#,  OBJ#,  DATAOBJ#,  CON_DBID) IN (SELECT NUM1_KEWRATTR,  NUM2_KEWRATTR,  NUM3_KEWRATTR,  NUM4_KEWRATTR FROM X$KEWRATTRSTALE)"
"insert into  WRH$_SYSSTAT  (dbid,  per_pdb,  con_dbid,  snap_id,  instance_number,  stat_id,  value)  select /*+ use_hash(v$sysstat) */  :dbid,   sysstat.con_id,  con_id_to_dbid(sysstat.con_id)  con_dbid,   :snap_id,  :instance_number,  stat_id,  value  FROM v$sysstat    sysstat  WHERE  (1 = 1)  AND ( sysstat.con_id &lt; 4099  )"
"update /* KSXM:FLUSH COL */ sys.col_usage$ set                  equality_preds    = equality_preds    + decode(bitand(:flag, 1), 0, 0, 1),    equijoin_preds    = equijoin_preds    + decode(bitand(:flag, 2), 0, 0, 1),    nonequijoin_preds = nonequijoin_preds + decode(bitand(:flag, 4), 0, 0, 1),    range_preds       = range_preds       + decode(bitand(:flag, 8), 0, 0, 1),    like_preds        = like_preds        + decode(bitand(:flag, 16), 0, 0, 1),    null_preds        = null_preds        + decode(bitand(:flag, 32), 0, 0, 1),    flags             = flags + :flag - bitand(flags, :flag),     timestamp = :time where obj# = :objn and intcol# = :coln"
"update wrm$_wr_control    set snap_interval = :bind1,  snapint_num = :bind2,  retention = :bind3,       retention_num = :bind4,  most_recent_snap_id = :bind5,       most_recent_snap_time = :bind6,  mrct_snap_time_num = :bind7,       status_flag = :bind8,  most_recent_purge_time = :bind9,       mrct_purge_time_num = :bind10,       most_recent_split_id = :bind11,  most_recent_split_time = :bind12,       swrf_version = :bind13,  registration_status = :bind14,       mrct_baseline_id = :bind15,  topnsql = :bind16,        mrct_bltmpl_id = :bind17,  src_dbid = :bind18,        src_dbname = :bind19,  t2s_dblink = :bind20,        flush_type = :bind21,  snap_align = :bind22,        mrct_snap_step_tm = :bind23,        mrct_snap_step_id = :bind24,        tablespace_name = :bind25  where dbid = :dbid"
"select count(*) from dba_autotask_window_clients c,  (select window_name,  max(log_date) max_log_date from dba_scheduler_window_log where operation = 'OPEN' group by window_name) wo,  (select window_name,  max(log_date) max_log_date from dba_scheduler_window_log where operation = 'CLOSE' group by window_name) wc where c.window_name = wo.window_name and c.optimizer_stats = 'ENABLED' and wo.window_name = wc.window_name and wo.max_log_date &lt; wc.max_log_date and wc.window_name not in (select h.window_name from dba_autotask_job_history h where h.client_name = 'auto optimizer stats collection' and h.job_start_time between wo.max_log_date and wc.max_log_date)"
"insert into  wrm$_snapshot_details  (snap_id, dbid, instance_number, table_id, begin_time, end_time, step_id)    values (:snap_id, :dbid, :instance_number, :bind1, :bind2, :bind3, :step_id)"
"INSERT /*+  LEADING(@&quot;SEL$F5BB74E1&quot; &quot;H&quot;@&quot;SEL$2&quot; &quot;A&quot;@&quot;SEL$1&quot;)  USE_NL(@&quot;SEL$F5BB74E1&quot; &quot;A&quot;@&quot;SEL$1&quot;)         */ INTO  WRH$_ACTIVE_SESSION_HISTORY  ( snap_id,  dbid,  instance_number ,  sample_id,  sample_time, sample_time_utc,  usecs_per_row ,  session_id,  session_serial#,  session_type ,  flags ,  user_id ,  sql_id,  sql_child_number,  sql_opcode,  force_matching_signature ,  top_level_sql_id,  top_level_sql_opcode ,  sql_plan_hash_value,  sql_full_plan_hash_value ,  sql_adaptive_plan_resolved ,  sql_plan_line_id ,  sql_plan_operation#,  sql_plan_options# ,  sql_exec_id,  sql_exec_start ,  plsql_entry_object_id,  plsql_entry_subprogram_id ,  plsql_object_id,        plsql_subprogram_id ,  qc_instance_id,  qc_session_id,  qc_session_serial#,  px_flags ,  event_id,  seq#,  p1,  p2,  p3 ,  wait_time,  time_waited ,  blocking_session,  blocking_session_serial#,  blocking_inst_id ,  current_obj#,  current_file#,  current_block#,  current_row# ,  top_level_call#,  consumer_group_id,  xid,  remote_instance#,  time_model ,  service_hash,  program,  module,  action,  client_id,  machine,  port,    ecid ,  dbreplay_file_id,  dbreplay_call_counter ,  con_dbid,  per_pdb ,  tm_delta_time,  tm_delta_cpu_time,  tm_delta_db_time,  delta_time,  delta_read_io_requests,  delta_write_io_requests,  delta_read_io_bytes,  delta_write_io_bytes,  delta_interconnect_io_bytes,  pga_allocated,  temp_space_allocated ,  dbop_name,  dbop_exec_id  )  (SELECT /*+ PARAM('_module_action_old_length', 0) */:snap_id,  :dbid,  :instance_number ,  a.sample_id,  a.sample_time, a.sample_time_utc ,  a.usecs_per_row * :disk_filter_ratio ,  a.session_id,  a.session_serial#,  a.session_type ,  decode(a.flags,  0,  to_number(NULL),  a.flags) ,  a.user_id ,  a.sql_id,  a.sql_child_number,  a.sql_opcode,  a.force_matching_signature ,  a.top_level_sql_id,  a.top_level_sql_opcode ,  a.sql_plan_hash_value,  a.sql_full_plan_hash_value ,  a.sql_adaptive_plan_resolved ,  a.sql_plan_line_id ,  a.sql_plan_operation#,  a.sql_plan_options# ,  a.sql_exec_id,  a.sql_exec_start ,  a.plsql_entry_object_id,  a.plsql_entry_subprogram_id ,  a.plsql_object_id,        a.plsql_subprogram_id ,  a.qc_instance_id,  a.qc_session_id,  a.qc_session_serial#,  a.px_flags ,  a.event_id,  a.seq#,  a.p1,  a.p2,  a.p3 ,  a.wait_time,  a.time_waited ,  a.blocking_session,  a.blocking_session_serial#,  a.blocking_inst_id ,  a.current_obj#,  a.current_file#,  a.current_block#,  a.current_row# ,  a.top_level_call#,  a.consumer_group_id,  a.xid,  a.remote_instance# ,  a.time_model ,  a.service_hash ,  substrb(a.program,  1,  64) ,  a.module,  a.action,  a.client_id,  a.machine,  a.port,  a.ecid ,  a.dbreplay_file_id,  a.dbreplay_call_counter ,  a.con_dbid,  a.con_id ,  decode(a.tm_delta_time,  0,  to_number(null),  a.tm_delta_time),  decode(a.tm_delta_time,  0,  to_number(null),  a.tm_delta_cpu_time),  decode(a.tm_delta_time,  0,  to_number(null),  a.tm_delta_db_time),  decode(a.delta_time,  0,  to_number(null),           a.delta_time),  decode(a.delta_time,  0,  to_number(null),           decode(a.delta_read_io_requests,  0,  to_number(null),                  a.delta_read_io_requests)),  decode(a.delta_time,  0,  to_number(null),           decode(a.delta_write_io_requests,  0,  to_number(null),                  a.delta_write_io_requests)),  decode(a.delta_time,  0,  to_number(null),           decode(a.delta_read_io_bytes,  0,  to_number(null),                  a.delta_read_io_bytes)),  decode(a.delta_time,  0,  to_number(null),           decode(a.delta_write_io_bytes,  0,  to_number(null),                  a.delta_write_io_bytes)),  decode(a.delta_time,  0,  to_number(null),           decode(a.delta_interconnect_io_bytes,  0,  to_number(null),                  a.delta_interconnect_io_bytes)),  decode(a.pga_allocated,  0,  to_number(null),  a.pga_allocated),  decode(a.pga_allocated,  0,  to_number(null),           decode(a.temp_space_allocated,  0,  to_number(null),                  a.temp_space_allocated)) ,  a.dbop_name,  a.dbop_exec_id  FROM     x$ash a,           (SELECT h.sample_addr,  h.sample_id           FROM   x$kewash h          WHERE                  ( (h.sample_id &gt;= :begin_flushing) and                   (h.sample_id &lt;  :latest_sample_id) )             and (nlssort(h.is_awr_sample, 'nls_sort=BINARY') =                  nlssort('Y',  'nls_sort=BINARY'))           ) shdr  WHERE  (1 = 1)  AND ( a.con_id &lt; 4099  )     and shdr.sample_addr     = a.sample_addr     and shdr.sample_id       = a.sample_id     and nlssort(a.need_awr_sample,  'nls_sort=BINARY') =         nlssort('Y',  'nls_sort=BINARY'))"
"select s.ts#,  s.file#,  s.block#,  so.object_id,  s.spare1,  s.type#,  s.hwmincr from seg$ s,  sys_objects so where bitand(s.spare1, 131072) = 0 and s.ts# = so.ts_number and s.file# = so.header_file and s.block# = so.header_block order by s.file# asc"
"select pob.parttype from sys.indpart$ ip,  sys.partobj$ pob  where ip.bo# = pob.obj# and ip.obj# = :oid"
SELECT property              FROM wri$_adv_tasks WHERE id = :task_num
select count(*) from ilmobj$ where rownum = 1
